import random
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button

#CONFIG
debug = False
no_noise = False
show_true = False
show_fig = True
save_images = True


random.seed( a=1738, )
main_x = 16
fig, (scatter, histo) = plt.subplots(nrows=2, ncols=1) #plt.figure(figsize=(12,10))

# Ray
# @param [a] coefficient of the x-squared term, optional
# @param [b] coefficient of the x term, optional
# @param [c] the y-intercent term, optional
# @param [x] the x term, optional
# @return {Number} y value of the function at the given x value
def true_value(a=0, b=0, c=0, x=0):
    return a*(x**2) + b*(x) + c

# Ray
# @param {r} upper bound of the noise
# @return {float} random float between [-(range/2), (range/2)]
def random_noise(r):
    if no_noise:
        return 0
    return (random.random() * r) - (r / 2)

# Ray
# @param {s} start, noise x value range
# @param {e} end, noise x value range
# @return {list} a list of noisy data
def get_noisy_data(s, e, data):
    list1 = []
    for i in range(s, e+1):
        tru_val = data[i]
        yval = tru_val + random_noise(e**2)
        noisy = (i, yval, tru_val) #x, y, o
        list1.append(noisy)
    return list1

def get_data(s, e):
    list1 = []
    for i in range(s, e+1):
        true_val = true_value(a=2, b=7, c=5, x=i)
        list1.append(true_val)
    return list1

# Ray
# Returns the correct yhat formula based on the degree of the polynomial
# @param {xs} a list of x values
# @param {ys} a list of y vales
# @return {list} a list containing the correct yhat formulas for given x values
def get_trendline(xs, ys, degree):
    list = []
    z = np.polyfit(xs, ys, degree)

    #iterate over the list of x values, assigning the correct yhat formula and appending to @return list[]
    for i, x in enumerate(xs):
        if degree == 1:
            yhat = x*z[0] + z[1]
        elif degree == 2:
            yhat = (x**2)*z[0] + x*z[1] + z[2]
        elif degree == 3:
            yhat = (x**3)*z[0] + (x**2)*z[1] + x*z[2] + z[3]
        elif degree == 4:
            yhat = (x**4)*z[0] + (x**3)*z[1] + (x**2)*z[2] + x*z[3] + z[4]
        else:
            raise Exception("INVALID DEGREE")
        list.append(yhat)
    return list

#Ray
# Calculates single residual
# @param {ys} the list of sample values
# @param {yhats} the values generated by the line of best fit
# @param {x} a single x value, interpretted as the index in the list
# @return a single residual
def get_residual(ys, yhats, x):
    return ys[x] - yhats[x]

# Ray
# gets multiple residual values at at x to populate histogram
# @param [n] number of iterations, optional
# @return None
def iterate(n=1000):
    start = 0
    end = 50
    data = get_data(start, end)
    diff = []
    magic_number = 1
    base = "../images/second_degree/trend_line/image_"
    ext = ".png"

    for i in range(n):
        fig.tight_layout()
        scatter.clear()
        histo.clear()
        list1 = get_noisy_data(start, end, data)

        xs, ys, os = [list(elem) for elem in zip(*list1)]
        ls = get_trendline(xs, ys, 2)

        diff.append(get_residual(ys, ls, (main_x-start)))

        if i % magic_number == 0:
            show_fig = True
        else:
            show_fig = False

        if n / 4 > i > 4:
            magic_number = 2
        elif n / 3 > i:
            magic_number = 5
        elif n / 2 > i:
            magic_number = 10
        elif n / .8 > i:
            magic_number = 50
        else:
            magic_number = n

        #show linear trendline
        if show_fig:
            scatter.scatter(xs, ys)
            scatter.plot(xs, ls, color='g')
            histo.axvline(main_x, color='b', linestyle='dashed', linewidth=1)
            histo.hist(diff, bins=int(np.sqrt(n)))

            if show_true:
                scatter.plot(xs, os, color='r') #graph true line NOT the trendline

            fig.tight_layout()
            fig.canvas.draw() #
            fig.show()
            if save_images:
                filename = base + str(i) + ext
                fig.savefig(filename)
            if debug:
                print(i)
                print(diff)
    sd = np.std(diff)
    mean = np.mean(diff)

    if debug:
        print(mean)
        print(sd)

    histo.hist(diff, bins=int(np.sqrt(n)))
    histo.axvline(mean, color='r', linestyle='dashed', linewidth=2)
    histo.axvline(mean+sd, color='r', linestyle='dashed', linewidth=1)
    histo.axvline(mean-sd, color='r', linestyle='dashed', linewidth=1)

    fig.canvas.draw()
    fig.show()
    if save_images:
        filename = base + str(i) + ext
        fig.savefig(filename)
    if debug:
        input("Waiting....")

iterate(100)
